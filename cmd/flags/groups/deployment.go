package groups

import (
	"context"
	"fmt"

	"github.com/ArjenSchwarz/fog/cmd/flags"
	"github.com/ArjenSchwarz/fog/cmd/flags/validators"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// DeploymentFlags represents deployment command flags with enhanced validation
// and flag grouping behaviour.
type DeploymentFlags struct {
	*flags.BaseFlagValidator

	// Core deployment flags
	StackName      string
	Template       string
	Parameters     string
	Tags           string
	Bucket         string
	ChangesetName  string
	DeploymentFile string

	// Deployment mode flags
	Dryrun          bool
	NonInteractive  bool
	CreateChangeset bool
	DeployChangeset bool
	DefaultTags     bool
}

// NewDeploymentFlags creates a new deployment flags group with default
// validation rules applied.
func NewDeploymentFlags() *DeploymentFlags {
	df := &DeploymentFlags{
		BaseFlagValidator: flags.NewBaseFlagValidator(),
		DefaultTags:       true,
	}

	df.setupValidationRules()
	return df
}

// setupValidationRules configures all validation rules for deployment flags.
func (df *DeploymentFlags) setupValidationRules() {
	// Stack name is always required
	df.AddRule(validators.NewRequiredFieldRule("stackname", func(_ flags.FlagValidator) interface{} {
		return df.StackName
	}))

	// Stack name format validation
	df.AddRule(validators.NewRegexRule("stackname", func(_ flags.FlagValidator) string {
		return df.StackName
	}, `^[a-zA-Z][a-zA-Z0-9-]*$`, "stack name must start with a letter and contain only letters, numbers, and hyphens"))

	// Deployment file conflicts with individual parameters
	df.AddRule(validators.NewConflictRule(
		[]string{"deployment-file", "template"},
		func(_ flags.FlagValidator, field string) interface{} {
			switch field {
			case "deployment-file":
				return df.DeploymentFile
			case "template":
				return df.Template
			default:
				return ""
			}
		},
	))

	df.AddRule(validators.NewConflictRule(
		[]string{"deployment-file", "parameters"},
		func(_ flags.FlagValidator, field string) interface{} {
			switch field {
			case "deployment-file":
				return df.DeploymentFile
			case "parameters":
				return df.Parameters
			default:
				return ""
			}
		},
	))

	df.AddRule(validators.NewConflictRule(
		[]string{"deployment-file", "tags"},
		func(_ flags.FlagValidator, field string) interface{} {
			switch field {
			case "deployment-file":
				return df.DeploymentFile
			case "tags":
				return df.Tags
			default:
				return ""
			}
		},
	))

	// Template is required when not using deployment file
	df.AddRule(&TemplateRequiredRule{df})

	// File existence validation
	df.AddRule(validators.NewFileExistsRule("template", func(_ flags.FlagValidator) string {
		return df.Template
	}, false))

	df.AddRule(validators.NewFileExistsRule("deployment-file", func(_ flags.FlagValidator) string {
		return df.DeploymentFile
	}, false))

	// Template file extension validation
	tmplExts := viper.GetStringSlice("templates.extensions")
	df.AddRule(validators.NewFileExtensionRule("template", func(_ flags.FlagValidator) string {
		return df.Template
	}, tmplExts))

	// Deployment file extension validation
	deployExts := viper.GetStringSlice("deployments.extensions")
	df.AddRule(validators.NewFileExtensionRule("deployment-file", func(_ flags.FlagValidator) string {
		return df.DeploymentFile
	}, deployExts))

	// Create and deploy changeset are mutually exclusive
	df.AddRule(&ChangesetModeRule{df})
}

// RegisterFlags registers all deployment flags on the provided command.
func (df *DeploymentFlags) RegisterFlags(cmd *cobra.Command) {
	cmd.Flags().StringVarP(&df.StackName, "stackname", "n", "", "The name for the stack")
	cmd.Flags().StringVarP(&df.Template, "template", "f", "", "The filename for the template")
	cmd.Flags().StringVarP(&df.Parameters, "parameters", "p", "", "The file(s) containing the parameter values, comma-separated for multiple")
	cmd.Flags().StringVarP(&df.Tags, "tags", "t", "", "The file(s) containing the tags, comma-separated for multiple")
	cmd.Flags().StringVarP(&df.Bucket, "bucket", "b", "", "The S3 bucket where the template should be uploaded to (optional)")
	cmd.Flags().StringVarP(&df.ChangesetName, "changeset", "c", "", "The name of the changeset, when not provided it will be autogenerated")
	cmd.Flags().StringVarP(&df.DeploymentFile, "deployment-file", "d", "", "The file to use for the deployment")
	cmd.Flags().BoolVar(&df.Dryrun, "dry-run", false, "Do a dry run: create the changeset and immediately delete")
	cmd.Flags().BoolVar(&df.NonInteractive, "non-interactive", false, "Run in non-interactive mode: automatically approve the changeset and deploy")
	cmd.Flags().BoolVar(&df.CreateChangeset, "create-changeset", false, "Only create a change set")
	cmd.Flags().BoolVar(&df.DeployChangeset, "deploy-changeset", false, "Deploy a specific change set")
	cmd.Flags().BoolVar(&df.DefaultTags, "default-tags", true, "Add any default tags that are specified in your config file")
}

// GetName returns the group name.
func (df *DeploymentFlags) GetName() string { return "deployment" }

// GetFlags returns the flag definitions for this group.
func (df *DeploymentFlags) GetFlags() []flags.FlagDefinition {
	return []flags.FlagDefinition{
		{Name: "stackname", Shorthand: "n", Description: "The name for the stack", Required: true, FlagType: flags.StringFlag},
		{Name: "template", Shorthand: "f", Description: "The filename for the template", FlagType: flags.StringFlag},
		{Name: "parameters", Shorthand: "p", Description: "The file(s) containing the parameter values", FlagType: flags.StringFlag},
		{Name: "tags", Shorthand: "t", Description: "The file(s) containing the tags", FlagType: flags.StringFlag},
		{Name: "bucket", Shorthand: "b", Description: "The S3 bucket for template upload", FlagType: flags.StringFlag},
		{Name: "changeset", Shorthand: "c", Description: "The name of the changeset", FlagType: flags.StringFlag},
		{Name: "deployment-file", Shorthand: "d", Description: "The file to use for deployment", FlagType: flags.StringFlag},
		{Name: "dry-run", Description: "Do a dry run", FlagType: flags.BoolFlag},
		{Name: "non-interactive", Description: "Run in non-interactive mode", FlagType: flags.BoolFlag},
		{Name: "create-changeset", Description: "Only create a change set", FlagType: flags.BoolFlag},
		{Name: "deploy-changeset", Description: "Deploy a specific change set", FlagType: flags.BoolFlag},
		{Name: "default-tags", Description: "Add default tags", DefaultValue: true, FlagType: flags.BoolFlag},
	}
}

// TemplateRequiredRule validates that template is provided when no deployment file is specified.
type TemplateRequiredRule struct{ flags *DeploymentFlags }

func (t *TemplateRequiredRule) Validate(ctx context.Context, _ flags.FlagValidator, _ *flags.ValidationContext) error {
	if t.flags.DeploymentFile == "" && t.flags.Template == "" {
		return fmt.Errorf("either --template or --deployment-file must be specified")
	}
	return nil
}

func (t *TemplateRequiredRule) GetDescription() string {
	return "template or deployment file is required"
}

func (t *TemplateRequiredRule) GetSeverity() flags.ValidationSeverity { return flags.SeverityError }

// ChangesetModeRule validates changeset mode flags.
type ChangesetModeRule struct{ flags *DeploymentFlags }

func (c *ChangesetModeRule) Validate(ctx context.Context, _ flags.FlagValidator, _ *flags.ValidationContext) error {
	if c.flags.CreateChangeset && c.flags.DeployChangeset {
		return fmt.Errorf("--create-changeset and --deploy-changeset cannot be used together")
	}
	return nil
}

func (c *ChangesetModeRule) GetDescription() string {
	return "changeset creation and deployment modes are mutually exclusive"
}

func (c *ChangesetModeRule) GetSeverity() flags.ValidationSeverity { return flags.SeverityError }

var _ flags.FlagGroup = (*DeploymentFlags)(nil)
var _ flags.FlagValidator = (*DeploymentFlags)(nil)
